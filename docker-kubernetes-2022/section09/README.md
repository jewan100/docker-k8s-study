# Multi Stage Build

> 하나의 Dockerfile 안에 여러 개의 `FROM` 단계를 정의해, 빌드용 이미지와 실행용 이미지를 분리하는 기법

## 개념

- Dockerfile 안에서 `FROM`을 여러 번 사용하는 방식
- 각 `FROM` 블록이 하나의 Stage(단계)역할

  - 예: `build` 단계, `test` 단계, `runtime` 단계

- 뒤에 나오는 단계가 앞 단계의 산출물을 선택적으로 가져와 사용하는 구조

  - 예: `COPY --from=build /app/build /usr/share/nginx/html` 같은 형태로 이전 단계 결과만 복사

## 왜 등장했는가?

- 많은 애플리케이션이 빌드 환경과 실행 환경이 다름

  - 프론트엔드

    - 빌드 시: Node, npm, webpack, babel 등 빌드 도구 필요
    - 실행 시: 빌드된 정적 파일을 Nginx 등으로 서빙하면 충분

  - 백엔드 (Java, Kotlin 등)

    - 빌드 시: JDK, Gradle, Maven 필요
    - 실행 시: JRE 혹은 `java -jar`만 있으면 충분

- 기존 방식의 문제점

  - 빌드 도구까지 포함된 “무거운 이미지”를 그대로 운영에 사용
  - 또는 “빌드용 Dockerfile”과 “실행용 Dockerfile”을 따로 관리해야 하는 번거로움

- Multi Stage Build의 목적

  - 하나의 Dockerfile 안에서 빌드, 테스트, 패키징, 실행 이미지를 모두 정의
  - 최종 이미지는 실행에 필요한 산출물만 포함하는 작고 가벼운 실행 환경으로 만드는 것

## 기본 구조 개념 예시

설명만 텍스트로 적으면 다음과 같은 흐름입니다.

1. 첫 번째 스테이지: 빌드 단계

   - 예: `FROM node:18-alpine AS build`
   - `WORKDIR /app`
   - `COPY package.json package-lock.json .`
   - `RUN npm ci`
   - `COPY . .`
   - `RUN npm run build`
   - 이 단계에서 소스 코드 빌드, 번들링 등 모든 빌드 작업 수행

2. 두 번째 스테이지: 실행 단계

   - 예: `FROM nginx:stable-alpine AS runtime`
   - `COPY --from=build /app/build /usr/share/nginx/html`
   - `EXPOSE 80`
   - `CMD ["nginx", "-g", "daemon off;"]`
   - 이 단계에는 빌드 결과물(정적 파일)만 복사하고, 빌드 도구는 포함하지 않음

요약하면, 빌드 전용 스테이지에서 만든 결과물을 런타임 전용 스테이지로 옮기는 구조입니다.

## 장점

### 1) 이미지 크기 감소

- 빌드 도구, 테스트 도구, 컴파일러 등을 최종 이미지에 포함하지 않음
- 최종 이미지는 실행에 필요한 런타임과 산출물만 포함
- 결과

  - 이미지 크기 감소
  - 네트워크 전송, 배포 속도 향상
  - 디스크 사용량 감소

### 2) 보안 향상

- 운영 컨테이너 안에 빌드 도구, 디버깅 도구, 컴파일러 등이 없음
- 공격 표면이 줄어들고, 취약점 가능성이 낮아지는 효과
- 원칙

  - 운영 이미지는 “필요한 것만 담는 최소 환경”으로 구성

### 3) 빌드 파이프라인 단순화

- 빌드용 Dockerfile, 실행용 Dockerfile을 따로 관리할 필요 없음
- 하나의 Dockerfile 안에

  - 빌드 단계
  - 테스트 단계
  - 패키징 단계
  - 실행 단계
    를 순서대로 정의 가능

- CI 파이프라인에서 `docker build` 한 번으로 전체 빌드 플로우를 캡슐화 가능

### 4) 언어·스택 독립적인 패턴

- Node + Nginx, Java/Kotlin, Go, Python 등 대부분의 스택에 동일하게 적용 가능

  - 빌드 스테이지: SDK, 빌드 도구 포함
  - 런타임 스테이지: JRE, 정적 바이너리, 최소 런타임만 포함

## 단점 및 주의사항

### 1) Dockerfile 복잡도 증가

- 스테이지가 많아질수록 Dockerfile이 길어지고 복잡해짐
- 역할이 섞이면 디버깅과 유지보수가 어려워짐
- 해결 방향

  - 스테이지 이름을 명확하게 정의 (`AS build`, `AS test`, `AS runtime` 등)
  - 각 스테이지의 책임을 분리해 설계

### 2) 캐시 전략 이해 필요

- 각 스테이지도 일반 Docker 레이어와 동일하게 캐싱 규칙을 따름
- 앞 단계에서 작은 변경을 해도, 그 이후 단계 캐시가 모두 무효화될 수 있음
- 일반적인 최적화 패턴

  - 의존성 설치(COPY package.json, RUN npm install 등)는 위쪽
  - 소스 코드 전체 COPY는 아래쪽
  - 변경이 적은 명령 → 위쪽, 자주 바뀌는 코드 → 아래쪽 배치

### 3) 디버깅 접근성

- 최종 실행 이미지는 정말 최소 구성이라, 빌드 도구나 디버깅 툴이 없음
- 실행 컨테이너 안에서 바로 빌드·디버깅을 하기는 어려움
- 대안

  - 빌드 스테이지 컨테이너를 별도로 띄워 디버깅
  - 필요하다면 `debug` 전용 스테이지를 하나 더 두고, 해당 이미지로 디버깅

## 언제 사용하면 좋은가?

- 빌드 단계와 실행 단계가 명확히 나뉘는 애플리케이션

  - 프론트엔드 (React, Vue, Next 등 정적 빌드)
  - Java / Kotlin (JDK로 빌드, JRE로 실행)

- 운영 환경 이미지 크기와 보안이 중요한 경우

  - 클라우드 환경, 대규모 배포 환경, 네트워크 제약이 큰 환경

- CI/CD 파이프라인에서

  - `docker build` 과정 안에 빌드, 테스트, 패키징을 함께 넣고 싶을 때

## 정리

- Multi Stage Build

  - 하나의 Dockerfile에서 여러 스테이지를 정의해, 빌드·테스트·실행 환경을 명확히 분리하는 기법
  - 최종 이미지를 가볍고 안전하게 만들기 위한 구조
  - 장점: 이미지 크기 감소, 보안 향상, 빌드 파이프라인 단순화, 스택 독립적 활용 가능
  - 단점: Dockerfile 복잡도 증가, 캐시 전략 이해 필요, 디버깅 접근성 이슈 존재
